const axios = require('axios');
const FormData = require('form-data');

class LogMealService {
  constructor() {
    this.apiKey = process.env.LOGMEAL_API_KEY;
    this.apiUrl = 'https://api.logmeal.com/v2';
    this.isConfigured = !!this.apiKey;
    this.userToken = null;
    this.userId = null;
    
    if (!this.isConfigured) {
      console.error('âŒ LOGMEAL_API_KEY not configured. Food detection will fail.');
    } else {
      console.log('âœ… LogMeal AI service initialized with API key');
    }
  }

  async ensureUserToken() {
    if (this.userToken) {
      return this.userToken;
    }

    try {
      console.log('ðŸ”‘ Creating LogMeal APIUser for food recognition...');
      const timestamp = Date.now();
      const response = await axios({
        method: 'POST',
        url: `${this.apiUrl}/users/signUp`,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        data: {
          username: `scan2suggest_${timestamp}`,
          password: 'TempPass123!',
          email: `scan2suggest+${timestamp}@example.com`
        },
        timeout: 15000
      });

      this.userToken = response.data.token;
      this.userId = response.data.userId;
      console.log('âœ… LogMeal APIUser created successfully');
      console.log('ðŸ”‘ User token received');
      return this.userToken;
    } catch (error) {
      console.error('âŒ Failed to create LogMeal APIUser:', error.message);
      console.error('âŒ Error response:', error.response?.data);
      console.error('âŒ Error status:', error.response?.status);
      throw new Error(`LogMeal user creation failed: ${error.message}`);
    }
  }

  async analyzeFood(imageBuffer, scanType) {
    // Require API key - no fallbacks
    if (!this.isConfigured) {
      throw new Error('LogMeal API key is required. Please configure LOGMEAL_API_KEY in environment variables.');
    }

    try {
      console.log(`ðŸ¤– Analyzing ${scanType} image with LogMeal AI...`);
      
      // Ensure we have a user token for food recognition
      const userToken = await this.ensureUserToken();
      
      // Create FormData for multipart/form-data request
      const formData = new FormData();
      formData.append('image', imageBuffer, {
        filename: 'scan.jpg',
        contentType: 'image/jpeg'
      });

      // Choose endpoint based on scan type
      let endpoint;
      if (scanType === 'food') {
        endpoint = '/recognition/dish'; // Complete food recognition
      } else {
        endpoint = '/image/recognition/type'; // Basic food type detection
      }

      const response = await axios({
        method: 'POST',
        url: `${this.apiUrl}${endpoint}`,
        headers: {
          'Authorization': `Bearer ${userToken}`,
          ...formData.getHeaders()
        },
        data: formData,
        timeout: 30000 // 30 second timeout
      });

      console.log('ðŸŽ¯ Raw LogMeal response:', JSON.stringify(response.data, null, 2));
      
      // Format the response to match our expected format
      const formattedItems = this.formatLogMealResponse(response.data, scanType);
      
      console.log(`âœ… LogMeal detected ${formattedItems.length} items`);
      return formattedItems;
      
    } catch (error) {
      console.error('âŒ LogMeal API error:', error.message);
      console.error('âŒ Full error stack:', error.stack);
      
      // No fallback - throw the error to be handled by the calling function
      throw new Error(`LogMeal API failed: ${error.message}`);
    }
  }

  formatLogMealResponse(logMealData, scanType) {
    console.log('ðŸ” Formatting LogMeal response:', JSON.stringify(logMealData, null, 2));
    
    if (!logMealData) {
      console.warn('âš ï¸ Invalid LogMeal response format');
      return [];
    }

    let formattedItems = [];

    if (scanType === 'food' && logMealData.recognition_results) {
      // Complete food recognition response
      const results = logMealData.recognition_results;
      
      if (results.length > 0) {
        formattedItems = results
          .filter(item => item.prob > 0.05) // Lower threshold for better detection
          .map(item => ({
            name: this.formatFoodName(item.name || 'Unknown Food'),
            confidence: Math.round(item.prob * 100) / 100,
            category: 'dish',
            boundingBox: {
              x: Math.round((item.x || 0) - ((item.w || 100) / 2)),
              y: Math.round((item.y || 0) - ((item.h || 100) / 2)),
              width: Math.round(item.w || 100),
              height: Math.round(item.h || 100)
            }
          }))
          .slice(0, 8); // Limit to 8 items max
      }
    } else if (logMealData.food_types) {
      // Food type detection response
      const foodTypes = logMealData.food_types;
      
      // Find the type with highest probability
      let maxProb = 0;
      let bestType = null;
      
      for (const foodType of foodTypes) {
        if (foodType.probs > maxProb) {
          maxProb = foodType.probs;
          bestType = foodType;
        }
      }
      
      if (bestType && maxProb > 0.3) {
        formattedItems = [{
          name: this.formatFoodName(bestType.name || 'Unknown'),
          confidence: Math.round(maxProb * 100) / 100,
          category: this.categorizeFood(bestType.name || 'food'),
          boundingBox: {
            x: 50,
            y: 50,
            width: 200,
            height: 150
          }
        }];
      }
    }
    
    console.log('âœ¨ Formatted LogMeal predictions:', formattedItems);
    
    return formattedItems;
  }


  formatFoodName(className) {
    // Convert class names to user-friendly format
    const nameMap = {
      'adobo': 'Chicken Adobo',
      'lechon': 'Lechon',
      'sinigang': 'Sinigang',
      'lumpia': 'Lumpia',
      'pancit': 'Pancit',
      'rice': 'Rice',
      'kare-kare': 'Kare-Kare',
      'sisig': 'Sisig',
      'bicol-express': 'Bicol Express',
      'dinuguan': 'Dinuguan'
    };
    
    return nameMap[className.toLowerCase()] || this.capitalizeWords(className);
  }

  capitalizeWords(str) {
    return str.replace(/\b\w/g, l => l.toUpperCase()).replace(/-/g, ' ');
  }

  categorizeFood(className) {
    const categories = {
      'adobo': 'dish',
      'lechon': 'dish', 
      'sinigang': 'dish',
      'lumpia': 'dish',
      'pancit': 'dish',
      'rice': 'food',
      'kare-kare': 'dish',
      'sisig': 'dish',
      'bicol-express': 'dish',
      'dinuguan': 'dish'
    };
    
    return categories[className.toLowerCase()] || 'food';
  }


  // Test method to verify API connectivity
  async testConnection() {
    if (!this.isConfigured) {
      return { success: false, message: 'LogMeal API key not configured' };
    }

    try {
      // Test by creating a user and then testing food recognition
      const userToken = await this.ensureUserToken();
      
      // Create a minimal test image buffer (1x1 pixel JPEG)
      const testImageBuffer = Buffer.from('/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k=', 'base64');
      
      const formData = new FormData();
      formData.append('image', testImageBuffer, {
        filename: 'test.jpg',
        contentType: 'image/jpeg'
      });

      const response = await axios({
        method: 'POST',
        url: `${this.apiUrl}/image/recognition/type`,
        headers: {
          'Authorization': `Bearer ${userToken}`,
          ...formData.getHeaders()
        },
        data: formData,
        timeout: 10000
      });

      return { 
        success: true, 
        message: 'LogMeal API connected successfully',
        response: response.data
      };
    } catch (error) {
      return { 
        success: false, 
        message: `LogMeal API connection failed: ${error.message}` 
      };
    }
  }
}

module.exports = new LogMealService();
